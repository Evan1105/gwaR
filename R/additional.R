# CODE: GWAS_meat_growth_traits Creation date:06/26/2015 Last modification:06/26/2015 Authors: DV SC JPS

#' efficiently calculates the diagonal of  \code{x*y*t(x)}.  
#'  @title Efficient computation of diagonals of matrix products
#' 
#' @param x A matrix of size n by m
#' @param y A symetric matrix of size m by m
#' @return A vector of length n 
#'  @export

diagprod <- function(x, y) {
    # by using this function the user will get the diagonal elements of X Y X' Check points If x and y are matrices
    if (!(is.matrix(x))) 
        stop("x must be a matrix")
    
    if (!(is.matrix(y))) 
        stop("y must be a matrix")
    
    # Rows in x are the same as columns in y
    if (ncol(x) != nrow(y)) 
        stop("Number of rows in x must be equal to the number of columns in y")
    
    # y is a square matrix
    if (nrow(y) != ncol(y)) 
        stop("y must be a square matrix")
    
    # ck the names if(colnames(x)!=rownames(y)) stop ('x and y must have the same order')
    
    diag_prod <- rowSums((x %*% y) * x)
    return(diag_prod)
}



#'  A frequency table of number of significant tests at given thresholds
#'  @title Significance summary for a \code{\link{gwas}} object
#'  @param gwas an object of the class gwas generated by \code{\link{gwas}}
#'  @param pvalue a vector with the p-value thresholds to build frequency table
#'  @param correction a string with value 'bonf' if compute bonferroni correction is needed
#'  @return a frequency table with the number of SNP significant at the thresholds specified by pvalue
#'  @export

summary.gwas <- function(gwas, pvalue = c(0.001, 0.01, 0.025, 0.05, 0.1), correction = "bonf") {
    
    if (is.null(gwas)) 
        stop("missing GWAS object")
    if (all(class(gwas) != "gwas")) 
        stop("object must be of class gwas")
    if (min(pvalue) < 0 || max(pvalue) > 1) 
        stop("range of pvalue must be between 0 and 1")
    
    
    if (correction == "bonf") {
        # Get the value that will be the threshold for those p values
        threshold <- qnorm(-pvalue/(2 * nrow(gwas)) + 1)
    } else {
        threshold <- qnorm(-pvalue/2 + 1)
        warning("no multiple test correction")
    }
    
    
    names(threshold) <- sub(0, replacement = "<0", pvalue)
    # Crate Standarization of the values (standarized_values)
    standarized_values <- gwas[["ghat"]]/sqrt(gwas[["var_ghat"]])
    
    
    # Compare those Standarized effects with the threshold, check which ones are bigger
    signif_values <- t(as.matrix(rowSums(sapply(abs(standarized_values), ">=", threshold))))
    rownames(signif_values) <- "signif.values"
    
    # change the name in case we want to use a print function
    class(signif_values) <- "summary.gwas"
    
    return(signif_values)
}


#' A function to create q-qplots of pvalues from high dimensional test (e.g: GWA, Differential expression analyses).  
#' @title q-qplots of p-values 

#' @param pvector A vector of pvalues, assumed to follow a uniform distribution under the null hypothesis
#' @param add a logical value, T: adds to existing graphic or F: creates a new graphic
#' @param ... additional parameters to parse to plot function
#' @return NULL. A graphic will be generated
#'  @export

qqgplot = function(pvector, add = F, ...) {
    o = -log10(sort(pvector, decreasing = F))
    e = -log10(1:length(o)/length(o))
    if (!add) {
        plot(e, o, ..., xlab = expression(Expected ~ ~-log[10](italic(p))), ylab = expression(Observed ~ ~-log[10](italic(p))), 
            xlim = c(0, max(e)), ylim = c(0, max(o) + 1))
    } else {
        points(e, o, ...)
    }
    lines(e, e, col = "red")
}

#' A function to create manhattan plots from GWA and QTL mapping analyses.  
#' @title Manhattan plots of p-values 

#' @param pvalues A vector of pvalues with SNP, marker or position names
#' @param map a genetic map: a data.frame with SNP or marker names in rows, chromosome name (chr column) and position (pos column)
#' @param threshold the threshold of significance 
#' @param col a vector of strings with color names for painting SNP according to their chromosome
#' @param ... additional graphical parameters used by plot 
#' @return NULL. A graphic is be generated
#'  @export

manhattan_plot <- function(pvalues, map, threshold = 0.01, col = c("black", "red"), chrom = NULL, ...) {
    if (!("chr" %in% colnames(map))) 
        stop("chr should be a column of map")
    if (sum(rownames(map) == names(pvalues)) < length(pvalues)) 
        stop("make sure that the values are ordered, rownames of map and names of p-value vector should agree")
    if ((max(pvalues) > 1) | (min(pvalues) < 0)) 
        stop("pvalues should be in the range [0,1]")
    if (sum(pvalues == 0) > 0) {
        pvalues[pvalues == 0] <- min(pvalues[pvalues > 0])
        warning("some p-values were exactly zero and they were replaced with the next smallest value")
    }
    if (!is.null(chrom)) {
        idx <- as.character(map$chr) %in% as.character(chrom)
        map <- map[idx, ]
        pvalues <- pvalues[idx]
    }
    if (length(col) < 2) 
        stop("two colors are needed in the color vector")
    mps <- as.numeric(as.factor(map$chr))
    plot(-log(pvalues, 10), pch = 20, col = col[(mps%%2) + 1], ylab = "-log10-pvalue", xlab = "chr", ..., axes = F)
    axis(2)
    lns <- (by(map, map$chr, nrow))
    axis(1, at = c(0, cumsum(lns)[-length(lns)]) + as.vector(lns/2), labels = names(lns))
    box()
    abline(h = -log(threshold, 10), lwd = 2, col = "green")
}

#'  Computes pvalues from a GWA class object represents them graphically. using \code{\link{manhattan_plot}} and \code{\link{qqgplot}}
#'  @title Significance plots and pvalues from \code{\link{gwas}} output
#'  @param gwas an object of the class gwas generated by \code{\link{gwas}}
#'  @param gpdata an object of class gpdata used to obtain a SNP map
#'  @param correction a string with value 'bonf' if compute bonferroni correction is needed
#'  @param plotlog10 a logical value indicating if a manhattan plot is requested
#'  @param q.qplot a logical value indicating if a q-qplot is requested
#'  @param pvalue significance threshold
#'  @param ... 
#'  @return a vector of pvalues with names equal to marker names. Optional output: Manhattan plot and q-qplot of pvalues
#'  @export

plot.gwas <- function(gwas, correction = "bonf", gpdata = NULL, plotlog10 = FALSE, pvalue = 0.05, 
                      q.qplot = FALSE, chrom = NULL, ...) {
    
    
    # get the significance level
    if (correction == "bonf") {
        # Get the value that will be the threshold for those p values
        threshold <- pvalue/nrow(gwas)
    } else {
        threshold <- pvalue
        warning("no multiple test correction")
    }
    map <- na.omit(gpdata$map)
    idx <- match(rownames(gwas), rownames(map))
    if (any(is.na(idx))) 
        warning("some markers in the gwa object are not present in the map")
    map <- map[idx, c("chr", "pos")]
    
    pval <- getpvalue(gwas, log.p = F)
    
    if (q.qplot == TRUE) {
        qqgplot(pvector = pval, main = NULL, add = F, ...)
    }
    
    if (plotlog10 == TRUE) {
        manhattan_plot(map = map, pvalues = pval, threshold = threshold, col = c("black", "red"), chrom = chrom, ...)
    }
    
}

#'  Pvalue for blup objects
#'  @title pvalue computation for a \code{\link{gwas}} object
#'  @param gwas an object of the class gwas generated by \code{\link{gwas}}
#'  @param log.p a logical value to indicate if log10-pvalues are requested
#'  @return a vector of p-values or log10 p-values
#'  @export

getpvalue <- function(gwas, log.p = T) {
    if (is.null(gwas)) 
        stop("missing GWAS object")
    if (all(class(gwas) != "gwas")) 
        stop("object must be of class gwas")
    # Get the standarized values of the SNP
    snpej <- gwas[["ghat"]]/sqrt(gwas[["var_ghat"]])
    names(snpej) <- rownames(gwas)
    # Calculate the p value
    pval <- (2 - 3 * log.p) * pnorm(abs(snpej), lower.tail = F, log.p = log.p)/(log(10)^log.p) - log.p * log10(2)
    return(pval)
} 
